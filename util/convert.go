// The Licensed Work is (c) 2022 Sygma
// SPDX-License-Identifier: BUSL-1.1

package util

import (
	"bytes"
	"errors"
	"math/big"
	"strings"
)

// Str2BigInt converts from string to big.Int
func Str2BigInt(small string) (*big.Int, error) {
	n := new(big.Int)
	n, ok := n.SetString(small, 10)
	if !ok {
		return nil, errors.New("failed to convert from string to bigInt")
	}
	return n, nil
}

func Large2SmallUnitConverter(large string, decimal uint) (*big.Int, error) {
	curFloat, ok := zero().SetString(large)
	if !ok {
		return big.NewInt(0), errors.New("failed to convert on the given decimal")
	}
	exp, _ := zero().SetString("1" + strings.Repeat("0", int(decimal)) + ".0")
	weiFloat := zero().Mul(curFloat, exp)
	weiInt, _ := weiFloat.Int(nil)
	return weiInt, nil
}

func zero() *big.Float {
	r := big.NewFloat(0.0)
	r.SetPrec(512)
	return r
}

func PaddingZero(data []byte, length int) []byte {
	b := bytes.Buffer{}

	for i := 0; i < length-len(data); i++ {
		b.WriteByte(0)
	}
	b.Write(data)

	return b.Bytes()
}

// Byte32Converter converts the first 32 bytes of given []byte to [32]byte
func Byte32Converter(b []byte) [32]byte {
	f := [32]byte{}
	copy(f[:], b)
	return f
}

func MsgGasLimitChecker(msgGasLimitParam string) (*big.Int, error) {
	msgGasLimit, err := Str2BigInt(msgGasLimitParam)
	if err != nil {
		return nil, err
	}
	if msgGasLimit.Cmp(big.NewInt(0)) == -1 {
		return nil, errors.New("MsgGasLimit can't be negative number")
	}
	return msgGasLimit, nil
}
